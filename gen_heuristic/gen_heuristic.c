/*
***********************************************************************************************************************
***********************************************************************************************************************
*** HAL9001 Rubix Cube Solving Robot - gen_heuristic.c
*** Chris Gerth - Summer 2014
*** 
*** Description: Creates a .h file with the heuristic lookup table in it
***
***********************************************************************************************************************
***********************************************************************************************************************
*/

#include "gen_heuristic.h"

/*Global Variables*/
listelem_t * list_head; /*points to head node*/
listelem_t * list_tail; /*points to tail node*/

int main()
{
    FILE * f =  NULL;
    
    init_data_structs();

    /*heuristic generation will be done via a Breadth-first search implemented through a doublly linked list*/
    /*each node in the search is expressed through one element of the linked list*/
    /*the basic process is as follows: the list is initialized with the identity (solved) cube. a new element */
    /*is generated from each possible move to the cube. The number of moves to reach that configuration  */
    /*is recorded in the temporary heuristic structure and to the element itself. If a number has already been */
    /*recorded into the heuristic structure, the element is not added back into the list, as expanding its children */
    /*will not gain any new information. Once all children of an element have been attempted, it is removed from the */
    /*list, and the process is repeated on the new head of the list. The process continues until the list is empty.*/
    /*Only one process should be running at a time, so all atomicity should not matter.*/
    
    /*initalize linked list*/
    list_head = init_list();
    list_tail = list_head;
    

    
    
    
    
    
    /*open heuristic file for writing*/
    f=fopen("src/heuristic.h", "w");
    if(f == NULL)
    {
        printf("ERROR: gen_heuristic.c - cannot open heuristic.h for writing.\n");
        return -1;
    }

    printf("Generating heuristic.h\n");
    /*write header information and guard #include's*/
    fprintf(f, " #ifndef HEURISTIC_HEADER\n");
    fprintf(f, " #define HEURISTIC_HEADER\n");
    fprintf(f, " /*\n");
    fprintf(f, " ***********************************************************************************************************************\n");
    fprintf(f, " ***********************************************************************************************************************\n");
    fprintf(f, " *** HAL9001 Rubix Cube Solving Robot - heuristic.h\n");
    fprintf(f, " *** Chris Gerth - Summer 2014\n");
    fprintf(f, " *** \n");
    fprintf(f, " *** WARNING: AUTOGENERATED. DO NOT EDIT. \n");
    fprintf(f, " *** Description: contains fixed tables for the heuristic functions\n");
    fprintf(f, " ***\n");
    fprintf(f, " ***********************************************************************************************************************\n");
    fprintf(f, " ***********************************************************************************************************************\n");
    fprintf(f, " */\n\n\n\n");
    
    /*write heuristic values to file*/
    
    /*close guard includes*/
    fprintf(f, " #endif\n");
    /*close file*/
    fclose(f);
    
    
    printf("Done!\n");
    return 0;
}

/*initalizes linked list with one element*/
/*returns pointer to head of list*/
listelem_t * init_list()
{
    listelem_t * head_of_list = NULL;
    head_of_list = (listelem_t*) malloc(sizeof(listelem_t)); /*make first list element*/
    
    if(head_of_list == NULL)
    {
        printf("ERROR: Unable to allocate memory for first list element\n");
        return NULL;
    }
    
    memcpy(&(head_of_list->cube), &Identity_Cube, sizeof(cube_t)); /*set first list element's cube to be the identity (solved) cube*/
    head_of_list->prev_elem = NULL;
    head_of_list->next_elem = NULL;
    
    return head_of_list;

}

/*makes a new element with the specified cube, and appends it to the end of the list*/
/*returns a pointer to the new element for error checking*/
listelem_t * append_element(cube_t * temp_cube)
{
    listelem_t * new_elem = (listelem_t*) malloc(sizeof(listelem_t)); /*make new list element*/
    
    if(new_elem == NULL)
    {
        printf("ERROR: Unable to allocate memory for new list element\n");
        return NULL;
    }
    memcpy(&(new_elem->cube), &(temp_cube), sizeof(cube_t)); /*copy cube into new element*/
    
    new_elem->prev_elem = list_tail;
    new_elem->next_elem = NULL;
    
    list_tail = new_elem;
    
    return new_elem;


}

/*removes the head of the list, sets the old next element as the new head*/
/*frees the associated memory*/
void remove_head()
{
    listelem_t * temp;
    temp = list_head;
    list_head = list_head->next_elem;
    list_head->prev_elem = NULL;
    free(temp);
    return;
}

